// Last updated: 8/14/2025, 10:39:38 PM
class Solution {
public:
    void solve(int node, int par, unordered_map<int,vector<int>>& graph, unordered_map<int,int>& parent , vector<int>& vis){

        vis[node] = 1;
        parent[node] = par;
        for(auto adj : graph[node]){
            if(!vis[adj]){
                solve(adj, par, graph, parent, vis);
            }
        }
        return;

    }
    int minMalwareSpread(vector<vector<int>>& adj, vector<int>& initial) {
        int n = adj.size();
        unordered_map<int,vector<int>> graph;
        unordered_map<int,int> childCount;

        for(int i = 0; i < n ; i++){
            for(int j = 0; j < n ; j++){
                if(adj[i][j] == 1) graph[i].push_back(j);
            }
        }
        vector<int> vis(n + 1 ,  0);
        unordered_map<int,int> parent;
        int par = 1;
        for(int i = 0; i < n ; i++){
            if(!vis[i]){
                solve(i, par, graph, parent, vis);
                par++;
            }
            childCount[parent[i]]++;
        }
        unordered_map<int,int> count;
        int smallestParentWithTwo = INT_MAX;
        for(int i = 0 ; i < initial.size(); i++){
            int node = initial[i];
            count[parent[node]]++;
            if(count[parent[node]] >= 2 ){
                smallestParentWithTwo = min(smallestParentWithTwo, parent[node]);
            }
        }
        // int smallestOne = INT_MAX;
        unordered_map<int,int> oneParents;
        for(auto i : count){
            if(i.second == 1){
                oneParents[i.first]++;
            }
        }
        int ans = INT_MAX;
        int prevCount = 0;
        if(!oneParents.empty()){
            for(auto i : initial){
                if(oneParents.find(parent[i]) != oneParents.end()){
                    if(childCount[parent[i]] > prevCount){
                        prevCount = childCount[parent[i]] ;
                        ans = i;
                    }
                    else if(childCount[parent[i]] ==  prevCount){
                        ans = min(ans, i);
                    }
                }
            } 
            return ans;
        }
        int deleteOne = smallestParentWithTwo ;
        for(auto i : initial ){
            ans = min(ans, i);
        }
        return ans;
        
    }

};